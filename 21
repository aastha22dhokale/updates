Nice — I implemented this exactly the way you requested:
	•	The service will only call onePamRepository.updatePostalAddress(wrapper, uuid, postalAddressUsageType) wherever your //Call update postal addr API comments currently are. (No request building in service.)
	•	The OnePamRepository method will build the request from OrganisationUnitDomainWrapper, call the OnePAM API, and parse the response — matching the style of updateOrganisationUnitName(...).
	•	I created the small request/response model classes (UpdatePostalAddressV5Request, UpdatePostalAddressV5Response) that follow the OnePAM API (only updatable fields + full postalAddress in response).

Paste the following files / snippets into your project.

⸻

1) Model — UpdatePostalAddressV5Request.java

Package: com.ing.datadist.api.model

package com.ing.datadist.api.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;

import java.io.Serializable;

@Generated
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UpdatePostalAddressV5Request implements Serializable {
    private static final long serialVersionUID = 1L;

    /**
     * Only these three fields are allowed to be updated according to the API:
     * - lastVerificationDate
     * - endDate
     * - deliveryFailureReasonType
     *
     * Date-time should be RFC3339 / ISO-8601 timestamp strings as used elsewhere in the project.
     */
    @JsonProperty("lastVerificationDate")
    private String lastVerificationDate;

    @JsonProperty("endDate")
    private String endDate;

    @JsonProperty("deliveryFailureReasonType")
    private String deliveryFailureReasonType;
}


⸻

2) Model — UpdatePostalAddressV5Response.java

Package: com.ing.datadist.api.model

package com.ing.datadist.api.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;

import java.io.Serializable;

@Generated
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UpdatePostalAddressV5Response implements Serializable {
    private static final long serialVersionUID = 1L;

    /**
     * Response contains the updated postalAddress object and links (same shape as OnePAM docs).
     */
    @JsonProperty("postalAddress")
    private PostalAddressResponse postalAddress;

    @JsonProperty("_links")
    private InvolvedPartiesLinkSelfResponse links;
}


⸻

3) Repository — add this method to OnePamRepository (package: com.ing.datadist.api.service)

This method builds UpdatePostalAddressV5Request from your OrganisationUnitDomainWrapper (only the allowed updatable fields), calls the OnePAM endpoint and parses UpdatePostalAddressV5Response. It follows the same try/catch and DataDistributionApiException style as updateOrganisationUnitName.

public CompletableFuture<UpdatePostalAddressV5Response> updatePostalAddress(
        com.ing.datadist.domain.OrganisationUnitDomainWrapper wrapper,
        String uuid,
        String postalAddressUsageType) {
    try {
        // Build request payload here (repo responsibility)
        UpdatePostalAddressV5Request payload = UpdatePostalAddressV5Request.builder()
                .lastVerificationDate(wrapper.getPostalAddressLastVerificationDate())   // ensure wrapper has this getter
                .endDate(wrapper.getPostalAddressEndDate())                             // ensure wrapper has this getter
                .deliveryFailureReasonType(wrapper.getPostalAddressDeliveryFailureReasonType()) // ensure wrapper has this getter
                .build();

        String url = RegkeyEnum.UPDATE_POSTAL_ADDRESS.resolveEndpoint(uuid, postalAddressUsageType);

        Request request = new RichHttpRequestBuilder()
                .withUrl(url)
                .withMethod(Method.Patch())
                .withJsonContent(payload)
                .withHeader("X-ING-LastUpdateUser", "X-ING-LastUpdateUser")
                .build();

        return apiClient.apply(request)
                .thenApply(response -> {
                    try {
                        return objectMapper.readValue(response.contentString(), UpdatePostalAddressV5Response.class);
                    } catch (Exception e) {
                        throw new DataDistributionApiException(
                                RegkeyEnum.UPDATE_POSTAL_ADDRESS,
                                "Failed to parse response from updatePostalAddress API",
                                e.getMessage()
                        );
                    }
                });
    } catch (RichHttpRequestBuilderException e) {
        throw new DataDistributionApiException(
                RegkeyEnum.UPDATE_POSTAL_ADDRESS,
                "Failed to build request for updatePostalAddress API",
                e.getMessage()
        );
    }
}

Notes & small adjustments you may need:
	•	I used wrapper getters:
	•	getPostalAddressLastVerificationDate()
	•	getPostalAddressEndDate()
	•	getPostalAddressDeliveryFailureReasonType()
If your OrganisationUnitDomainWrapper uses different field names, replace those getters in the repository method with the correct ones (or add them to the wrapper). The wrapper must supply the three fields that are allowed to be updated.
	•	If you instead prefer the repo to accept explicit strings, we can change the signature to (String lastVerificationDate, String endDate, String deliveryFailureReasonType, String uuid, String usageType). But per your last message, you wanted the service to just pass wrapper, so I used wrapper.

⸻

4) Service — change each comment to a single repo call

Replace every //Call update postal addr API inside UpdateOrganisationUnitService.updateOrganisationUnit(...) with this single line:

onePamRepository.updatePostalAddress(wrapper, uuid, address.getPostalAddressUsageType());

Example context (complete replacement for one of the commented blocks):

if (Objects.equals(wrapper.getPostalAddressStreetNm(), address.getStreetName())) {
    log.info("Update organisationUnit StreetName changed for uuid:{} old:{} new:{} ",
            uuid, wrapper.getPostalAddressStreetNm(), address.getStreetName());

    // call OnePAM repo — repo will build request and call API
    onePamRepository.updatePostalAddress(wrapper, uuid, address.getPostalAddressUsageType());
}

Do that for every postal-address-related //Call update postal addr API comment block (HouseNum, HouseAdd, PostalCd, CityName, CountryCode).

⸻

5) RegkeyEnum — ensure entry exists (you already have it, but verify formatting)

Make sure RegkeyEnum contains:

UPDATE_POSTAL_ADDRESS("UPDATE_POSTAL_ADDRESS", jakarta.ws.rs.HttpMethod.PATCH, "https://api.ing.com/v5/involved-parties/{uuid}/postal-addresses/{postalAddressUsageType}")

(Your enum earlier already had this; just ensure the endpoint string and method are correct and the enum punctuation is valid — there must be commas between entries.)

⸻

Quick checklist for you (to avoid compile errors)
	1.	Add the two model classes (UpdatePostalAddressV5Request, UpdatePostalAddressV5Response) into com.ing.datadist.api.model.
	2.	Add the repository method into your existing OnePamRepository class (same file).
	3.	Replace the //Call update postal addr API comments in UpdateOrganisationUnitService.updateOrganisationUnit(...) with the single-line call shown above.
	4.	Confirm OrganisationUnitDomainWrapper exposes the getters I referenced (or adapt method to actual getters).
	5.	Confirm RegkeyEnum.UPDATE_POSTAL_ADDRESS exists exactly as used earlier.

⸻

If you want I can:
	•	Update my repo method to accept explicit strings instead of wrapper (if you prefer fewer wrapper-field dependencies).
	•	Provide a small helper in repo for mapping/wrapping.
	•	Also add the same pattern for digital address next.

Tell me if you want me to adapt the repository method signature to (UpdatePostalAddressV5Request payload, String uuid, String usageType) instead — otherwise this exact code follows your requested pattern (service only calling repo; repo builds request).
