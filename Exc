Great ‚Äî this is very clean, and YES you can extend this single class to hold ALL 4 flow exceptions inside it.

You already have a base class:

DataDistributionApiException

Now we simply add nested static exception subclasses inside this SAME file.

No more 4 files.
No more multiple imports.
All flow-level exceptions stay grouped.

‚∏ª

‚úÖ Updated DataDistributionApiException with ALL 4 flow exception types

üëâ Replace your file with this complete merged version:

package com.ing.datadist.api.exception;

import com.ing.datadist.api.utils.RegkeyEnum;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import java.text.MessageFormat;
import org.springframework.http.HttpStatus;

import static com.ing.datadist.api.utils.DataDistributionConstants.CLIENT_ERROR;
import static org.apache.commons.lang3.StringUtils.isNotBlank;

@Slf4j
@Getter
@ToString
@EqualsAndHashCode(callSuper = true)
public class DataDistributionApiException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    private final int code;
    private final String innerMessage;
    private final String timeStamp;

    private static final String LOG_MESSAGE = "ReqKey {0} - DataDistributionApiException message {1} - innerMessage {2}";
    private static final String WARNING_CODE = "WarningCode";

    public DataDistributionApiException(RegkeyEnum reqKeyEnum, String message, String innerMessage) {
        this(reqKeyEnum, CLIENT_ERROR, message, innerMessage);
    }

    public DataDistributionApiException(RegkeyEnum reqKeyEnum, int code, String message, String innerMessage) {
        super(message);
        this.code = code;
        this.innerMessage = innerMessage;
        this.timeStamp = String.valueOf(System.currentTimeMillis());

        if (isNotBlank(message) && isNotBlank(innerMessage)) {
            MDC.put(WARNING_CODE, innerMessage);
            log.error(MessageFormat.format(LOG_MESSAGE, reqKeyEnum.label, message, innerMessage));
        }
    }

    public DataDistributionApiException(RegkeyEnum regkeyEnum, HttpStatus httpStatus, String innerMessage) {
        super(httpStatus.getReasonPhrase());
        this.code = httpStatus.value();
        this.innerMessage = innerMessage;
        this.timeStamp = String.valueOf(System.currentTimeMillis());

        if (isNotBlank(httpStatus.getReasonPhrase()) && isNotBlank(innerMessage)) {
            MDC.put(WARNING_CODE, innerMessage);
            log.error(MessageFormat.format(LOG_MESSAGE, regkeyEnum.label, httpStatus.getReasonPhrase(), innerMessage));
        }
    }

    public static DataDistributionApiException from(RegkeyEnum key, HttpStatus status, String innerMessage) {
        return new DataDistributionApiException(key, status, innerMessage);
    }

    // ============================================================
    // üî• NESTED FLOW EXCEPTIONS (ALL IN ONE CLASS)
    // ============================================================

    // 1Ô∏è‚É£ Creation failure
    public static class OrganisationUnitCreationException extends DataDistributionApiException {
        public OrganisationUnitCreationException(String msg) {
            super(RegkeyEnum.CREATE_INVOLVED_PARTY, msg, msg);
        }
    }

    // 2Ô∏è‚É£ External Identifier update failure
    public static class ExternalIdentifierUpdateException extends DataDistributionApiException {
        public ExternalIdentifierUpdateException(String msg, Throwable cause) {
            super(RegkeyEnum.UPDATE_EXTERNAL_ID, msg, cause != null ? cause.getMessage() : msg);
            initCause(cause);
        }
    }

    // 3Ô∏è‚É£ Postal Address creation failure
    public static class PostalAddressCreationException extends DataDistributionApiException {
        public PostalAddressCreationException(String msg, Throwable cause) {
            super(RegkeyEnum.CREATE_POSTAL_ADDRESS, msg, cause != null ? cause.getMessage() : msg);
            initCause(cause);
        }
    }

    // 4Ô∏è‚É£ Organisation hierarchy creation failure
    public static class OrganisationHierarchyCreationException extends DataDistributionApiException {
        public OrganisationHierarchyCreationException(String msg, Throwable cause) {
            super(RegkeyEnum.CREATE_ORGANISATION_UNIT_HIERARCHY, msg, cause != null ? cause.getMessage() : msg);
            initCause(cause);
        }
    }
}


‚∏ª

‚úÖ How to use now in your service

Since these are now inner classes:

import static com.ing.datadist.api.exception.DataDistributionApiException.*;

throw new OrganisationUnitCreationException("Missing UUID");
throw new ExternalIdentifierUpdateException("Failed external ID update", e);
throw new PostalAddressCreationException("Failed postal address", e);
throw new OrganisationHierarchyCreationException("Failed hierarchy", e);

Your service will compile exactly the same.

‚∏ª

üéâ All 4 exceptions ‚Üí now in ONE class

You didn‚Äôt lose type safety.
You didn‚Äôt lose custom messages.
You gained clean code and grouping.

‚∏ª

If you want, I can refactor your entire OrganisationUnitService with these nested exceptions applied cleanly.
